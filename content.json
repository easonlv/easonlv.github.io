{"meta":{"title":"Diving into Data","subtitle":"略懂一些算法，只会几种编程语言，半栈工程师，不靠谱分析师。","description":"Algorithm Data Mining Machine Learning","author":"Eason Lv","url":"http://easonlv.github.io"},"pages":[{"title":"","date":"2016-09-28T11:13:34.000Z","updated":"2016-09-28T11:13:34.000Z","comments":false,"path":"tags/index.html","permalink":"http://easonlv.github.io/tags/index.html","excerpt":"","text":"title: tags date: 2016-09-28 19:12:36"}],"posts":[{"title":"一书一世界","slug":"一书一世界","date":"2017-03-26T08:34:11.000Z","updated":"2017-04-10T12:01:07.000Z","comments":true,"path":"2017/03/26/一书一世界/","link":"","permalink":"http://easonlv.github.io/2017/03/26/一书一世界/","excerpt":"","text":"一书一世界读《岛上书店》岛上书店的原著英文名是The Storied Life of A.J. Fikry，正如英文名直译费克里富有戏剧性的人生，讲述了书店老板A.J.充满故事的生命中，遇到了一些可爱的人，经历着爱与被爱、付出与接受、孤独与陪伴的一生。 A.J. Fikry住在爱丽丝岛上，一个小岛，他拥有岛上唯一的书店，不过最近他更喜欢喝酒，而不是卖书，因为他在为惨死车祸中的妻子妮可感到悲伤。A.J.和妮可是大学的同学，同样都是研究文学的博士生毕业，这也算是志同道合的一对了。妮可去世后，A.J.的颓废使得书店遭遇危机，屋漏偏逢连夜雨，书店里最宝贵的珍藏本图书《帖木儿》也遭窃了。仿佛命运从未眷顾过他，他的内心沦为了荒岛。 就在此时，神秘的小女孩玛雅，出现在书店中， 看似A.J.照顾起这个孤儿，其实也是玛雅意外地拯救了陷于孤独绝境中的A.J.，并且成为了连接他和小姨子伊斯梅、警长兰比亚斯、出版社女业务员阿米莉娅之间的纽带。 阿米莉娅Amelia是一位出版社代表，邀请爱丽丝书店出售本季最新的作品。 A.J.一开始对她并不友好，后来在接触中慢慢心生爱意。这位中年男人不懂的怎样表达，甚至连去她家看望她都很含蓄，连玛雅看着都急，好在最后两个人终在一起。伊斯梅是妮可的姐姐，也就是A.J.的小姨子，可惜遇到了一个花心的丈夫和一个个谎言，最后和警长兰比亚斯心生爱意。兰比亚斯是A.J.的好朋友，职业的敏感让他在伊斯梅家中发现了一些秘密：关于玛雅的身世、那本被盗的书…… 小岛上的主要人物和故事还有很多，但他们的生命紧紧相依，并最终一起走出了人生的困境，遗憾的是A.J.没有战胜肿瘤而离去，书店也有了新的主人，所有对书和生活的热爱都周而复始，愈加汹涌。 如果你喜欢阅读，喜欢书籍和书店，我相信这是一部能吸引你的小说。这儿有些书中的经典语录。 A.J.：“想要了解一个人，你只需要问一个问题‘你最喜欢哪本书？’”“一旦一个人在乎一件事，就发现自己不得不开始在乎一切事。” A.J.向阿米莉亚求婚：“……我可以向你保证有书、有交流，还有我的全心全意，艾米。” 兰比亚斯：“有时候别人跟你说你踏上一种旅程，结果却成了另外一种旅程。”“生活中每一桩糟糕事，几乎都是时机不当的结果，每件好事，都是时机恰到好处的结果。” 《迟暮开花》：“因为从心底害怕自己不值得被爱，我们独来独往。然而就是因为独来独往，才让我们以为自己不值得被爱。有一天，你不知道是什么时候，你会驱车上路。有一天，你不知道是什么时候，你会遇见他。你会被爱，因为你今生第一次真正不再孤单。你会选择不再孤单下去。” 我是利用早上上班坐地铁的半个多小时和晚上睡觉前躺床上看一小时书的时间，零散且不急不慢地在读。从一开始的情节迷茫、情感复杂到最后的人物心理反思，隐情的慢慢暴露，从开始的颓废到心里充满希望走出困境，小岛上的生活仿佛与世隔绝，而爱是最好的礼物，让一无所有的孤岛成为丰富美丽的存在。 所以，每一本书，都是一个世界。","categories":[{"name":"读书","slug":"读书","permalink":"http://easonlv.github.io/categories/读书/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://easonlv.github.io/tags/读书笔记/"}],"keywords":[{"name":"读书","slug":"读书","permalink":"http://easonlv.github.io/categories/读书/"}]},{"title":"Mac系统安装Xgboost","slug":"Mac系统安装Xgboost","date":"2017-03-24T14:40:41.000Z","updated":"2017-03-24T15:01:59.000Z","comments":true,"path":"2017/03/24/Mac系统安装Xgboost/","link":"","permalink":"http://easonlv.github.io/2017/03/24/Mac系统安装Xgboost/","excerpt":"","text":"Mac系统安装XgboostXgboost是大规模并行boosted tree的工具，它是目前最快最好的开源boosted tree工具包，比常见的工具包快10倍以上。在数据科学方面，有大量kaggle选手选用它进行数据挖掘比赛，其中包括两个以上kaggle比赛的夺冠方案。在工业界规模方面，xgboost的分布式版本有广泛的可移植性，支持在YARN, MPI, Sungrid Engine等各个平台上面运行，并且保留了单机并行版本的各种优化，使得它可以很好地解决于工业界规模的问题。 本文是我今天在Mac系统下成功安（cai）装（keng）Xgboost的笔记（Windows系统用户请出门左转），Mac系统10.12版本按照Xgboost官网安装指南，出现了错误。 如果按照传统Python库用pip来安装：sudo pip install xgboost，同样出现了错误，最后亲测下面方法安装成功。 1.安装 HomebrewHomebrew是Mac系统下非常优秀的包管理工具，相当于Ubuntu的apt-get，安装命令： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2.安装最新版本的gcc，即gcc-6Mac系统默认有Python、Ruby、Shell等环境，但是没有gcc和g++的，安装XCode之后会有clang，而XCode自带的clang是不支持OpenMP的，所以需要重新安装gcc。这个过程比较久，一直在下载，网速快的话差不多半个多小时吧。 1brew install gcc --without-multilib 3.下载Xgboost的git源码12git clone --recursive https://github.com/dmlc/xgboost cd xgboost 4.修改配置文件，用于编译1cp make/config.mk ./config.mk 用vim打开config.mk，修改下面两行： 12export CC = gcc-6export CXX = g++-6 这样做是为了用之前下载的gcc-6而不是系统已有的gcc来编译。本来按照官网的 make -j4 来编译，但是未成功，所以改用下面这种方法来编译： 1./build.sh 5.安装python版Xgboost安装Xgboost的Python版需要Numpy、Scipy等数值计算库，建议安装Anaconda，所有的科学计算和数据挖掘库都安装好了。 12cd python-packagesudo python setup.py install 6.打开Python验证1&gt;&gt;&gt; import xgboost as xgb OK，没有报错，安装成功。下面你可以用Xgboost算法来玩数据了，官网有好多Example来学习。 12345678910import xgboost as xgb# read in datadtrain = xgb.DMatrix('demo/data/agaricus.txt.train')dtest = xgb.DMatrix('demo/data/agaricus.txt.test')# specify parameters via mapparam = &#123;'max_depth':2, 'eta':1, 'silent':1, 'objective':'binary:logistic' &#125;num_round = 2bst = xgb.train(param, dtrain, num_round)# make predictionpreds = bst.predict(dtest) 如果你想玩kaggle比赛，Xgboost这把屠龙刀更不可少。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://easonlv.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://easonlv.github.io/tags/机器学习/"},{"name":"xgboost","slug":"xgboost","permalink":"http://easonlv.github.io/tags/xgboost/"}],"keywords":[{"name":"机器学习","slug":"机器学习","permalink":"http://easonlv.github.io/categories/机器学习/"}]},{"title":"spark学习之RDD","slug":"spark学习之RDD","date":"2016-10-03T15:47:41.000Z","updated":"2017-04-10T12:01:22.000Z","comments":true,"path":"2016/10/03/spark学习之RDD/","link":"","permalink":"http://easonlv.github.io/2016/10/03/spark学习之RDD/","excerpt":"","text":"1.RDD基础Spark对数据的核心抽象——弹性分布式数据集(Resilient Distributed Dataset,简称RDD)。RDD其实就是分布式的元素集合。在 Spark中,对数据的所有操作不外乎创建 RDD、转化已有RDD以及调用RDD操作进行求值。而在这一切背后,Spark会自动将RDD中的数据分发到集群上,并将操作并行化执行。 2. 创建RDDSpark提供了两种创建 RDD 的方式: 读取外部数据集 1val lines = sc.textFile(&quot;/path/to/README.md&quot;) 在程序中对一个集合进行并行化 1val lines = sc.parallelize(List(\"pandas\", \"i like pandas\")) 3. RDD操作RDD 支持两种操作: 转化操作 transformation 和 行动操作 action 3.1 转化操作转化操作是返回一个新的 RDD 的操作,比如 map() 和 filter()map() 接收一个函数,把这个函数用于 RDD 中的每个元素, 将函数的返回结果作为结果RDD中对应元素的值。 如用Scala 实现map计算 RDD中各值的平方： 123val input = sc.parallelize(List(1, 2, 3, 4))val result = input.map(x =&gt; x * x)println(result.collect().mkString(&quot;,&quot;)) flatMap()和 map() 类似,函数被分别应用到了输入 RDD 的每个元素上,不过返回的不是一个元素,而是一个返回值序列的迭代器。即对每个输入元素生成多个输出元素，得到由各列表中的元素组成的 RDD。filter() 则接收一个函数,并将 RDD 中满足该函数的 元素放入新的 RDD 中返回，如用 Scala 实现 filter() 转化操作: 12val inputRDD = sc.textFile(&quot;log.txt&quot;)val errorsRDD = inputRDD.filter(line =&gt; line.contains(&quot;error&quot;)) 函数 功能 示例 结果 map() 将函数应用于 RDD 中的每个元素,将返回值构成新的RDD rdd.map(x =&gt; x + 1) {2, 3, 4, 4} flatMap() 将函数应用于 RDD 中的每个元素,将返回的迭代器的所有内容构成新的RDD，通常用来切分单词 rdd.flatMap(x =&gt; x.to(3)) {1, 2, 3,2, 3, 3, 3} filter() 返回一个由通过传给 filter() 的函数的元素组成的 RDD rdd.filter(x =&gt; x != 1) {2, 3, 3} distinct() 去重 rdd.distinct() {1, 2, 3} sample(withReplacement, fraction, [seed]) 对 RDD 采样,以及是否替换 rdd.sample(false, 0.5) 非确定的 3.2 行动操作行动操作则是向程序返回结果或把结果写入外部系统的操作,会触发实际的计算,比如 count() 和 first()在 Scala 中使用行动操作对错误进行计数： 123println(&quot;Input had &quot; + badLinesRDD.count() + &quot; concerning lines&quot;)println(&quot;Here are 10 examples:&quot;)badLinesRDD.take(10).foreach(println) reduce()接收一个函数作为参数,这个函数操作两个RDD的元素类型的数据并返回一个同样类型的新元素。一个简单的例子就是函数 + ,可以用它来对RDD进行累加。Scala 中的 reduce()： 1val sum = rdd.reduce((x, y) =&gt; x + y) fold() 和 reduce() 类似,接收一个与 reduce() 接收的函数签名相同的函数,再加上一个 “初始值”来作为每个分区第一次调用时的结果。例如 + 对应的 0, * 对应的 1,或拼接操作对应的空列表 collect() 函数可以用来获取整个 RDD 中的数据，但collect() 不能用在大规模数据集上，仅当整个数据集能在单台机器的内存中放得下时才能使用。 saveAsTextFile()、saveAsSequenceFile(),或者任意的其他行动操作来把 RDD 的数据内容以各种自带的格式保存起来。 4. RDD持久化默认情况下RDD的内容是临时的，但Spark提供了在RDD中持久化数据的机制。第一次调用动作并计算出RDD内容后，RDD的内容可以存储在集群的内存或磁盘上。这样下一次需要调用依赖该RDD的动作时，就不需要从依赖关系中重新计算RDD，数据可以从缓存分区中直接返回： cached.cache()cached.count()cached.take(10) 在上述代码中，cache方法调用指示在下次计算RDD后，要把RDD存储起来。调用count会导致第一次计算RDD。采取（take）这个动作返回一个本地的Array，包含RDD的前10个元素。但调用take时，访问的是cached已经缓存好的元素，而不是从cached的依赖关系中重新计算出来的。 当Spark持久化存储一个RDD 时，计算出 RDD 的节点会分别保存它们所求出的分区数据。如果一个有持久化数据的节点发生故障，Spark会在需要用到缓存的数据时重算丢失的数据分区。Spark为持久化RDD定义了几种不同的机制，用不同的StorageLevel值表示。 rdd.cache()是rdd.persist(StorageLevel.MEMORY)的简写，它将RDD存储为未序列化的对象。","categories":[],"tags":[{"name":"spark","slug":"spark","permalink":"http://easonlv.github.io/tags/spark/"}],"keywords":[]},{"title":"Implemention of QuickSork","slug":"Implemention-of-QuickSork","date":"2016-09-24T16:55:25.000Z","updated":"2017-04-10T12:01:37.000Z","comments":true,"path":"2016/09/25/Implemention-of-QuickSork/","link":"","permalink":"http://easonlv.github.io/2016/09/25/Implemention-of-QuickSork/","excerpt":"","text":"快速排序###算法过程快速排序 的思想很简单，整个排序过程只需要三步： 在数据集之中，找一个基准点； 建立两个数组，分别存储左边和右边的数组； 利用递归进行下次比较。 Java代码1234567891011121314151617181920212223242526272829303132333435public class QuickSort &#123; //一次划分 public static int partition(int[] arr, int left, int right) &#123; int pivotKey = arr[left]; int pivotPointer = left; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey) right --; while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey) left ++; swap(arr, left, right); //把大的交换到右边，把小的交换到左边。 &#125; swap(arr, pivotPointer, left); //最后把pivot交换到中间 return left; &#125; public static void quickSort(int[] arr, int left, int right) &#123; if(left &gt;= right) return ; int pivotPos = partition(arr, left, right); quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right); &#125; public static void sort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1); &#125; public static void swap(int[] arr, int left, int right) &#123; int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; &#125;&#125; C代码12345678910111213141516171819202122232425int Division(int a[],int left, int right) //分割&#123; int base=a[left]; //基准元素 while(left&lt;right) &#123; while(left&lt;right &amp;&amp; a[right]&gt;base) --right; //从右向左找第一个比基准小的元素 a[left]=a[right]; while(left&lt;right &amp;&amp; a[left]&lt;base ) ++left; //从左向右找第一个比基准大的元素 a[right]=a[left]; &#125; a[left]=base; return left;&#125;void QuickSort(int a[],int left,int right)&#123; int i,j; if(left&lt;right) &#123; i=Division(a,left,right); //分割 QuickSort(a,left,i-1); //将两部分分别排序 QuickSort(a,i+1,right); &#125;&#125; JavaScript代码123456789101112131415161718192021function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr;//如果数组只有一个数，就直接返回； &#125; var num = Math.floor(arr.length/2);//找到中间数的索引值，如果是浮点数，则向下取整 var numValue = arr.splice(num,1);//找到中间数的值 var left = []; var right = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;numValue)&#123; left.push(arr[i]);//基准点的左边的数传到左边数组 &#125; else&#123; right.push(arr[i]);//基准点的右边的数传到右边数组 &#125; &#125; return quickSort(left).concat(numValue,quickSort(right));//递归不断重复比较&#125;alert(quickSort([32,45,37,16,2,87]));//弹出“2,16,32,37,45,87” Python代码12345678910111213141516171819202122232425#!/usr/bin/python# -*- coding: utf-8 -*-def sub_sort(array,low,high): key = array[low] while low &lt; high: while low &lt; high and array[high] &gt;= key: high -= 1 while low &lt; high and array[high] &lt; key: array[low] = array[high] low += 1 array[high] = array[low] array[low] = key return lowdef quick_sort(array,low,high): if low &lt; high: key_index = sub_sort(array,low,high) quick_sort(array,low,key_index) quick_sort(array,key_index+1,high)if __name__ == '__main__': array = [8,10,9,6,4,16,5,13,26,18,2,45,34,23,1,7,3] print array quick_sort(array,0,len(array)-1) print array R代码1234567891011121314151617qsort &lt;- function(v) &#123; if ( length(v) &gt; 1 ) &#123; pivot &lt;- (min(v) + max(v))/2.0 c(qsort(v[v &lt; pivot]), v[v == pivot], qsort(v[v &gt; pivot])) &#125; else v&#125;N &lt;- 100vs &lt;- runif(N)system.time(u &lt;- qsort(vs))print(u)Qsort &lt;- function(x)&#123; if (length(x) &lt; 2) return(x) return(c(Qsort(x[x&lt;x[1]]), x[x==x[1]], Qsort(x[x&gt;x[1]])))&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://easonlv.github.io/tags/数据结构/"}],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2016-09-22T07:14:27.000Z","updated":"2016-09-22T07:14:27.000Z","comments":true,"path":"2016/09/22/hello-world/","link":"","permalink":"http://easonlv.github.io/2016/09/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}